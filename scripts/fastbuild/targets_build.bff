
.KindOutDir_StaticLib = 'lib'
.KindOutDir_SharedLib = 'bin'
.KindOutDir_ConsoleApp = 'bin'
.KindOutDir_WindowedApp = 'bin'
.KindOutDir_HeaderOnly = 'inc'
.KindOutDir_ObjectList = ''

.KindTags_StaticLib = { 'Library' }
.KindTags_SharedLib = { 'Library', 'Binary' }
.KindTags_ConsoleApp = { 'App', 'Binary', 'Console' }
.KindTags_WindowedApp = { 'App', 'Binary', 'Windowed' }
.KindTags_HeaderOnly = { }
.KindTags_ObjectList = { 'Library' }

.ConanVariables_StaticLib = { 'IncludeDirs', 'Defines' }
.ConanVariables_SharedLib = { 'IncludeDirs', 'Defines', 'LibDirs', 'Libs' }
.ConanVariables_ConsoleApp = { 'IncludeDirs', 'Defines', 'LibDirs', 'Libs' }
.ConanVariables_WindowedApp = { 'IncludeDirs', 'Defines', 'LibDirs', 'Libs' }
.ConanVariables_HeaderOnly = { 'IncludeDirs', 'Defines' }
.ConanVariables_ObjectList = { 'IncludeDirs', 'Defines' }

.TaskType_Compile = 'Compile'
.TaskType_Link = 'Link'
.TaskType_Test = 'Test'
.TaskType_Exec = 'Exec'
.TaskType_Copy = 'Copy'
.TaskType_Deploy = 'Deploy'
.TaskType_ValidList = {
    .TaskType_Compile
    .TaskType_Link
    .TaskType_Test
    .TaskType_Exec
    // .TaskType_Copy
    .TaskType_Deploy
}

.Step_Build = 'Build'
.Step_Deploy = 'Deploy'

.Piepline_CompileVSTargetsNames = { }
.Piepline_CompileVSTargets = [ ]
.Pipeline_LocalCompilerTargets = [ ]

//
// Prepare global build rules
//
.Final_GlobalTags = { }
.Final_GlobalRules = { }
.Final_AliasList = { }
.Final_CleanAliasList = { }

ForEach( .GlobalRule in .GlobalRules )
{
    Using( .EmptyProperties )
    Using( .GlobalRule )

    .Final_GlobalRule =
    [
        .Name = .Name
        .RuleRequires = .Requires
        .RuleDependsOn = []
        .RuleProperties_Public = [ ]
        .RuleProperties_Private =
        [
            .Uses = .Uses
            .Modules = ^Modules
            .IncludeDirs = ^IncludeDirs
            .Defines = ^Defines
            .BuildOptions = ^BuildOptions
            .Libs = ^Libs
            .LibDirs = ^LibDirs
            .LinkOptions = ^LinkOptions
            .LinkLinkerOptions = ^LinkLinkerOptions
        ]
    ]
    ^Final_GlobalRules + .Final_GlobalRule
}

Print( '[IBT] Creating build targets...' )

//
// For each available pipeline create all targets
//
ForEach( .Pipeline in .AvailablePipelines )
{
    .PipelineSolutionInfo = []
    .PipelineProjectRequirements = { }
    .PipelineDefinesCompilers = false

    Using( .Pipeline )

    .PipelineTargets = { }
    .PipelineCleanTargets = { }
    .PipelineEnabledProjects = { }
    .PipelineProperties_Public = []

    ForEach( .Project in .ProjectsResolved )
    {
        .ProjectAllowUnityBuilds = true

        Using( .Project )

        .AvailableTags = .PipelineAvailableSDKs
            + .PipelineTags

        // Check if we the project has all requirements covered
        .ProjectRequirementsSatisfied = false
        {
            .AvailableTags + .PipelineEnabledProjects

            If ( ( .RequiresAny_EmptyToken in .ProjectRequiresAny ) || ( .ProjectRequiresAny in .AvailableTags ) )
            {
                ^ProjectRequirementsSatisfied = true

                // Expand project requirements for this scope only
                .ProjectRequires + .PipelineDynamicRequirements

                ForEach( .Requirement in .ProjectRequires )
                {
                    If ( .Requirement not in .AvailableTags )
                    {
                        // Print( "INFO: $ProjectName$ is missing requirement `$Requirement$` for ($PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$)" )
                        ^ProjectRequirementsSatisfied = false
                    }
                }
            }

            If ( .ProjectRequirementsSatisfied )
            {
                ForEach ( .Requirement in .PipelineProjectRequirements )
                {
                    If ( .Requirement not in .ProjectTags )
                    {
                        // Print( "INFO: $ProjectName$ is not enabled for ($PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$) missing `$Requirement$`" )
                        ^ProjectRequirementsSatisfied = false
                    }
                }
            }
        }

        // Build targets for the project
        If ( .ProjectRequirementsSatisfied )
        {
            ^PipelineEnabledProjects + .ProjectName

            .AvailableTags + .ProjectTags

            // First iteration to search for rules changing the project kind
            // We check with limited tags
            ForEach( .ProjectRule in .ProjectRules )
            {
                .RuleDeploy = false
                .RuleKind = .Kind_None
                Using( .ProjectRule )

                .RuleRequirementsSatisfied = false

                If ( ( .RequiresAny_EmptyToken in .RuleRequiresAny ) || ( .RuleRequiresAny in .AvailableTags ) )
                {
                    ^RuleRequirementsSatisfied = true

                    ForEach( .Requirement in .RuleRequires )
                    {
                        If ( .Requirement not in .AvailableTags )
                        {
                            ^RuleRequirementsSatisfied = false
                        }
                    }
                }

                If ( .RuleRequirementsSatisfied )
                {
                    // Update project kind if needed
                    If ( .RuleKind != .Kind_None )
                    {
                         Print( "$ProjectName$ ($PipelineConfig$)" )
                        ^ProjectKind = .RuleKind
                    }

                    If ( .RuleDeploy )
                    {
                        ^ProjectDeploy = .RuleDeploy
                    }
                }
            }

            .AvailableTags + .ProjectKind

            // Final list of rules for the current step
            .StepRules = { }
            ForEach( .PipelineRule in .PipelineRules )
            {
                Using( .EmptyProperties )
                Using( .PipelineRule )

                .Final_PipelineRule =
                [
                    .Name = .Name
                    .RuleRequires = .Requires
                    .RuleDependsOn = []
                    .RuleProperties_Public = [ ]
                    .RuleProperties_Private =
                    [
                        .Uses = .Uses
                        .Modules = ^Modules
                        .IncludeDirs = ^IncludeDirs
                        .Defines = ^Defines
                        .BuildOptions = ^BuildOptions
                        .Libs = ^Libs
                        .LibDirs = ^LibDirs
                        .LinkOptions = ^LinkOptions
                        .LinkLinkerOptions = ^LinkLinkerOptions
                        .DependsOn = ^DependsOn
                    ]
                ]
                ^StepRules + .Final_PipelineRule
            }

            .StepRules
                + .ProjectRules
                + .Final_GlobalRules

            .TargetTriple = '$PipelineName$-$PipelinePlatform$-$PipelineConfig$'
            // .ProjectTarget = '$ProjectName$-$PipelineName$-$PipelineConfig$'
            .ProjectTarget = '$ProjectName$-$TargetTriple$-$PipelineToolchain$'
            .ProjectStruct = '$ProjectName$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
            .ProjectSubTargets = { }

            Using( .EmptyProperties )

            // Prepare a struct where we can hold all targets defined in a step
            .Step_Previous = 'INIT'
            .Step_TargetsContainer =
            [
                .Step_Targets_INIT = {}
                .Step_Outputs_INIT = {}
            ]

            // Some helper variables so we dont duplicate target creation
            .Step_CopyDirsTargets = { }


            // Go through each project task and generate final tasks if applicable
            {
                .TaskToolOperationsNames = { }

                Using( .PipelinePlatformInfo )
                Using( .PipelineProperties_SDKs )

                .NewPipelineStepTasks =
                [
                    Using( .PipelineStepTasks )

                    ForEach( .ProjectTask in .ProjectTasks )
                    {
                        .TaskStep = 'PostBuild'

                        Using( .ProjectTask )

                        If ( .TaskStep in .PipelineSteps )
                        {
                            If ( .TaskOperation in .TaskToolOperationsNames )
                            {
                                .ExecArguments = ''
                                .ExecInputPattern = '*.*'

                                .TaskConsumesPreviousOutputs = false
                                Using( .'Operation_$TaskOperation$' )

                                .FinalTask =
                                [
                                    .Step = .TaskStep
                                    .Type = .TaskType_Exec

                                    .TaskID = '$ProjectName$-$TaskOperation$'
                                    .TaskConsumesPreviousOutputs = .TaskConsumesPreviousOutputs

                                    .ExecExecutable = .'$ExecName$'
                                    .ExecInput = { }
                                    .ExecInputPath = { }
                                    .ExecArguments = .ExecArguments
                                    .ExecInputPattern = .ExecInputPattern
                                ]

                                ForEach( .Option in .OperationOptions )
                                {
                                    .OptionPrefix = ''
                                    .OptionSuffix = ''
                                    .IsInputDependency = false
                                    Using( .Option )

                                    If ( .IsInputDependency )
                                    {
                                        .TaskExtension =
                                        [
                                            .ExecInput = '$SourceVar$'
                                        ]
                                        ^FinalTask + .TaskExtension
                                    }

                                    If ( .TargetType == 'String' )
                                    {
                                        .TaskExtension =
                                        [
                                            .'$TargetVar$' = ''

                                            If ( .SourceType == 'List' )
                                            {
                                                ForEach( .Value in .'$SourceVar$' )
                                                {
                                                    ^'$TargetVar$' + '$OptionPrefix$$Value$$OptionSuffix$'
                                                }
                                            }

                                            If ( .SourceType == 'String' )
                                            {
                                                .Value = .'$SourceVar$'
                                                ^'$TargetVar$' + '$OptionPrefix$$Value$$OptionSuffix$'
                                            }
                                        ]
                                        ^FinalTask + .TaskExtension
                                    }

                                    If ( .TargetType == 'List' )
                                    {
                                        .TaskExtension =
                                        [
                                            .'$TargetVar$' = .'$SourceVar$'
                                        ]
                                        ^FinalTask + .TaskExtension
                                    }
                                }

                                ^'$TaskStep$_Tasks' + .FinalTask
                            }
                        }
                    }
                ]
                ^PipelineStepTasks = .NewPipelineStepTasks
            }

            // Go through each step
            ForEach( .Step in .PipelineSteps )
            {
                .AvailableTags + "Step-$Step$"

                .ProjectStepStruct = 'PublicProperties_$Step$_$ProjectStruct$'
                .ProjectStepProperties_Public = []
                .ProjectStepProperties_Combined = []
                .ProjectStepDependencies = []
                .ProjectStepUnitTest = [ ]

                ForEach( .Rule in .StepRules )
                {
                    // Append tags for the current project kind
                    .AvailableTags + .'KindTags_$ProjectKind$'

                    // Check if we ment the rule requirements
                    .Name = "<null>"
                    .RuleRequires = { }
                    .RuleRequiresAny = { .RequiresAny_EmptyToken }

                    Using( .EmptyProperties )
                    Using( .Rule )

                    .RuleRequirementsSatisfied = false
                    If ( ( .RequiresAny_EmptyToken in .RuleRequiresAny ) || ( .RuleRequiresAny in .AvailableTags ) )
                    {
                        ^RuleRequirementsSatisfied = true

                        ForEach( .Dependency in .Uses )
                        {
                            ^RuleRequires + '$Dependency$-$PipelineName$-$ConfigPlatform$-$ConfigName$'
                        }

                        ForEach( .Requirement in .RuleRequires )
                        {
                            If ( .Requirement not in .AvailableTags )
                            {
                                ^RuleRequirementsSatisfied = false
                            }
                        }
                    }

                    // Print( "$ProjectName$ ($PipelineConfig$ $Step$ ($Name$) == $RuleRequirementsSatisfied$" )
                    // Print( "$ProjectKind$" )

                    If ( .RuleRequirementsSatisfied )
                    {
                        .RuleUnitTests =
                        [
                            .Enabled = false
                        ]

                        // Gether dependency properties
                        .GatheredDependencies = { }
                        .GatheredProperties = {
                            'Modules'
                            'Defines'
                            'IncludeDirs'
                            'BuildOptions'
                            'Libs'
                            'LibDirs'
                            'LinkOptions'
                            'LinkLinkerOptions'
                            'DependsOn'
                        }

                        Using( .EmptyProperties )

                        .RuleStepProject_FinalProperties_Private =
                        [
                            Using( .RuleProperties_Private )

                            // Create empty dependency property structs
                            {
                                .PipelineProperties_Private_Empty = []
                                ForEach( .Dependency in .Uses )
                                {
                                    .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                    .PipelineProperties_Private_Empty_Extension =
                                    [
                                        .'$DependencyStruct$' =
                                        [
                                            Using( .EmptyProperties )
                                            .HasLinkTarget = false
                                            ; .CopyModules = false
                                        ]
                                    ]
                                    ^PipelineProperties_Private_Empty + .PipelineProperties_Private_Empty_Extension
                                }

                                Using( .PipelineProperties_Private_Empty )
                                Using( .PipelineProperties_Public )

                                // Gather private uses
                                {
                                    .UsesUnique = .Uses
                                    ForEach( .Dependency in .Uses )
                                    {
                                        .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                        Using( .'$DependencyStruct$' )

                                        ForEach( .Value in .Uses )
                                        {
                                            If ( .Value not in .UsesUnique )
                                            {
                                                ^UsesUnique + .Value
                                            }
                                        }
                                    }
                                    ^Uses = .UsesUnique
                                }
                            }
                        ]

                        // Enable `interface` dependency visibility for less restrictive build setup
                        .RuleStepProject_FinalProperties_Interface =
                        [
                        ]

                        .RuleStepProject_FinalProperties_Public =
                        [
                            Using( .RuleProperties_Public )

                            // Create empty dependency property structs
                            {
                                .PipelineProperties_Public_Empty = []
                                ForEach( .Dependency in .Uses )
                                {
                                    .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                    .PipelineProperties_Public_Empty_Extension =
                                    [
                                        .'$DependencyStruct$' =
                                        [
                                            Using( .EmptyProperties )
                                            .HasLinkTarget = false
                                            ; .CopyModules = false
                                        ]
                                    ]
                                    ^PipelineProperties_Public_Empty + .PipelineProperties_Public_Empty_Extension
                                }

                                Using( .PipelineProperties_Public_Empty )
                                Using( .PipelineProperties_Public )

                                // Gather public uses
                                {
                                    .UsesUnique = .Uses
                                    ForEach( .Dependency in .Uses )
                                    {
                                        .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                        Using( .'$DependencyStruct$' )

                                        ForEach( .Value in .Uses )
                                        {
                                            If ( .Value not in .UsesUnique )
                                            {
                                                ^UsesUnique + .Value
                                            }
                                        }
                                    }
                                    ^Uses = .UsesUnique
                                }
                            }
                        ]

                        .RuleFinalCombinedProperties = [ ]
                            + .RuleStepProject_FinalProperties_Private
                            + .RuleStepProject_FinalProperties_Interface
                            + .RuleStepProject_FinalProperties_Public

                        .RuleStepProject_FinalProperties_Combined =
                        [
                            Using( .RuleFinalCombinedProperties )

                            .LibraryTargets = { }

                            {
                                // Create empty dependency property structs
                                .PipelineProperties_Private_Empty = []
                                {
                                    ForEach( .Dependency in .Uses )
                                    {
                                        .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                        .PipelineProperties_Private_Empty_Extension =
                                        [
                                            .'$DependencyStruct$' =
                                            [
                                                Using( .EmptyProperties )
                                                .HasLinkTarget = false
                                                ; .CopyModules = false
                                            ]
                                        ]
                                        ^PipelineProperties_Private_Empty + .PipelineProperties_Private_Empty_Extension
                                    }
                                }

                                {
                                    Using( .PipelineProperties_Private_Empty )
                                    Using( .PipelineProperties_Public )

                                    ForEach( .Dependency in .Uses )
                                    {
                                        If ( .Dependency not in .GatheredDependencies )
                                        {
                                            ^GatheredDependencies + .Dependency
                                            .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'

                                            // Print( "$ProjectName$: Gathering $Dependency$..." )

                                            ForEach( .Property in .GatheredProperties )
                                            {
                                                Using( .'$DependencyStruct$' )
                                                ^'$Property$' + .'$Property$'
                                            }

                                            {
                                                Using( .'$DependencyStruct$' )
                                                If ( .HasLinkTarget )
                                                {
                                                    ^LibraryTargets + .Dependency
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            .Uses = .GatheredDependencies

                            ^ProjectStepDependencies + .DependsOn
                        ]

                        ^ProjectStepProperties_Public + .RuleStepProject_FinalProperties_Public
                        ^ProjectStepProperties_Combined + .RuleStepProject_FinalProperties_Combined
                        ^ProjectRequires + .RuleRequires

                        {
                            Using( .Rule )
                            Using( .RuleUnitTests )
                            If ( .Enabled )
                            {
                                ^ProjectStepUnitTest = .RuleUnitTests
                            }
                        }
                    }

                } // ForEach( .Rule in .ProjectPipelineConfigRules )

                // Update the public struct of the project
                {
                    .PipelineProperties_PublicExtension =
                    [
                        .'$ProjectStepStruct$' =
                        [
                            Using( .ProjectStepProperties_Public )

                            .HasLinkTarget = true
                            If ( .ProjectKind == .Kind_HeaderOnly )
                            {
                                ^HasLinkTarget = false
                            }
                        ]
                    ]
                    ^PipelineProperties_Public + .PipelineProperties_PublicExtension
                }

                Using( .PipelineOutputExtensions )
                Using( .PipelineToolchainInfo )

                // Print( "Target: $ProjectTarget$" )

                .OutDirName = .'KindOutDir_$ProjectKind$'
                .TargetExtension = .'OutputExtension_$ProjectKind$'

                .TargetIntermediateDirectory = '$WorkspaceBuildDir$/obj/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$/$ProjectName$'
                .TargetImpLibDirectory = '$WorkspaceBuildDir$/lib/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$/$ProjectName$'
                .TargetOutputDirectory = '$WorkspaceBuildDir$/$OutDirName$/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$/$ProjectName$'
                .TargetDeployDirectory = '$WorkspaceBuildDir$/deploy/$ProjectName$/$PipelineName$-$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$'
                .TargetTestOutputDirectory = '$WorkspaceBuildDir$/tests/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$'
                .TargetTaskOutputDirectory = '$WorkspaceBuildDir$/tasks/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$'
                .TargetOutputName = "$ProjectName$$TargetExtension$"
                .TargetList = { }

                If ( .PipelineOutputDirSuffix != .EmptyString )
                {
                    ^TargetOutputDirectory = '$TargetOutputDirectory$/$PipelineOutputDirSuffix$'
                    ^TargetDeployDirectory = '$TargetDeployDirectory$/$PipelineOutputDirSuffix$'
                }

                // Define a clean target
                .ProjectCleanTarget = "$ProjectTarget$-clean"
                If ( .ProjectCleanTarget not in .PipelineCleanTargets )
                {
                    RemoveDir( '$ProjectTarget$-clean' )
                    {
                        .RemovePaths = {
                            .TargetOutputDirectory
                            .TargetDeployDirectory
                            .TargetImpLibDirectory
                            .TargetIntermediateDirectory
                        }
                        .RemovePathsRecurse = false
                    }
                    ^PipelineCleanTargets + '$ProjectTarget$-clean'
                }

                If ( .ProjectKind in .Kind_Libraries )
                {
                    .Prefix = .'OutputPrefix_$ProjectKind$'
                    ^TargetOutputName = '$Prefix$$TargetOutputName$'
                }

                // Print( "IntDir: $TargetIntermediateDirectory$" )
                // Print( "LibDir: $TargetImpLibDirectory$" )
                // Print( "Output: $TargetOutputDirectory$/$TargetOutputName$" )
                // Print( .RuleProperties )

                // Dependency list
                //--------------------------------------------------------------------------
                .StepDependencies = { }

                {
                    .'$Step$' = {}

                    Using( .ProjectStepDependencies )

                    ForEach( .Dependency in .'$Step$' )
                    {
                        If ( .Dependency in .PipelineEnabledProjects )
                        {
                            .DependencyTargetName = '$Dependency$-$TargetTriple$-$PipelineToolchain$-$Step$'
                            ^StepDependencies + .DependencyTargetName
                        }
                    }
                }


                .FinalProperties = .ProjectStepProperties_Combined

                // Project specific SDK
                ForEach( .SDKName in .SDKNames, .SDK in .SDKList )
                {
                    If ( .SDKName not in .PipelineTags )
                    {
                        If ( .SDKName in .ProjectRequires )
                        {
                            .SDKSupportedPlatforms = { }
                            Using( .SDK )
                            If ( .PipelinePlatform in .SDKSupportedPlatforms )
                            {
                                ^FinalProperties + .SDK
                            }
                        }
                    }
                }

                .FinalProperties
                    + .PipelineProperties_SDKs
                    + .PipelineProperties_Toolchain

                // External dynamic libararies
                //--------------------------------------------------------------------------
                {
                    .Runtime = { }
                    .RuntimeExternal = { }
                    .RuntimeLibsPaths = [ ]
                    .KnownLibs = { }

                    Using( .FinalProperties )
                    Using( .ProjectStepDependencies )
                    Using( .RuntimeLibsPaths )

                    .RuntimeNew = { }
                    ForEach( .Dependency in .Runtime )
                    {
                        If ( .Dependency in .KnownLibs )
                        {
                            ForEach( .KnownLib in .KnownLibs, .KnownLibPath in .KnownLibsPath )
                            {
                                If ( .Dependency == .KnownLib )
                                {
                                    ^RuntimeExternal + '$KnownLibPath$'
                                }
                            }
                        }
                        If ( .Dependency not in .KnownLibs )
                        {
                            ^RuntimeNew + .Dependency
                        }
                    }

                    If ( .CopyModules )
                    {
                        .CopyExternal = false
                        .CopyExternalFiles = { }
                        ForEach( .External in .RuntimeExternal )
                        {
                            ^CopyExternal = true
                            If ( .External not in .CopyExternalFiles )
                            {
                                ^CopyExternalFiles + .External
                            }
                        }

                        If ( .CopyExternal )
                        {
                            .CopyExternalTargetName = '$ProjectTarget$-copyexternal'

                            If ( .CopyExternalTargetName not in .Step_CopyDirsTargets )
                            {
                                // Only do this once
                                ^Step_CopyDirsTargets + .CopyExternalTargetName
                                If ( !.ProjectDeploy ) // Only copy for non-deploy projects
                                {
                                    Copy( '$CopyExternalTargetName$' )
                                    {
                                        .Source = .CopyExternalFiles
                                        .Dest = '$TargetOutputDirectory$/'
                                    }
                                }
                                ^StepDependencies + .CopyExternalTargetName
                            }
                        }
                    } // If ( .CopyModules )

                    .ProjectStepDependenciesNew =
                    [
                        Using( .ProjectStepDependencies )
                        .Runtime = .RuntimeNew
                        .RuntimeExternal = ^RuntimeExternal
                    ]
                    ^ProjectStepDependencies = .ProjectStepDependenciesNew
                }

                // Conan Modules
                //--------------------------------------------------------------------------
                .ConanModules = { }
                .ConanModulesNames = { }

                ForEach( .ConanProfile in .ConanProfiles, .ConanProfileModules in .ConanProfilesModules )
                {
                    If ( .PipelineConanProfile != .EmptyString )
                    {
                        If ( .ConanProfile == .PipelineConfigConanProfile )
                        {
                            Using( .ConanProfileModules )
                            If ( .ConanModulesDefined )
                            {
                                Using( .FinalProperties )
                                // Using( .'ConanModules_$PipelineConfigConan$' )

                                ForEach( .ConanModule in .Modules )
                                {
                                    If ( .ConanModule not in .ConanModulesNames )
                                    {
                                        ^ConanModulesNames + .ConanModule
                                        ^ConanModules + .'ConanModule_$ConanModule$'
                                    }
                                }
                            }
                        }
                    }
                }


                ForEach( .ConanModuleName in .ConanModulesNames, .ConanModule in .ConanModules )
                {
                    Using( .FinalProperties )
                    Using( .ConanModule )

                    If ( .CopyModules )
                    {
                        .CopyDirs = false
                        .CopyDirsList = { }
                        ForEach( .BinDir in .BinDirs )
                        {
                            ^CopyDirs = true
                            ^CopyDirsList + "$BinDir$/"
                        }

                        If ( .CopyDirs )
                        {
                            .CopyDirTargetName = '$ProjectTarget$-$ConanModuleName$-copydir'

                            If ( .CopyDirTargetName not in .Step_CopyDirsTargets )
                            {
                                // Only do this once
                                ^Step_CopyDirsTargets + .CopyDirTargetName

                                If ( .ProjectDeploy )
                                {
                                    CopyDir( '$CopyDirTargetName$' )
                                    {
                                        .SourcePaths = .CopyDirsList
                                        .SourcePathsPattern = { '*.dll', '*.so*' }
                                        .Dest = '$TargetDeployDirectory$/'
                                    }
                                }
                                If ( !.ProjectDeploy )
                                {
                                    CopyDir( '$CopyDirTargetName$' )
                                    {
                                        .SourcePaths = .CopyDirsList
                                        .SourcePathsPattern = { '*.dll', '*.so*' }
                                        .Dest = '$TargetOutputDirectory$/'
                                    }
                                }
                                ^StepDependencies + .CopyDirTargetName
                            }
                        }
                    } // If ( .CopyModules )

                } // If ( .ConanModule not in .ConanModulesNames )

                // Apply link step all flags
                //--------------------------------------------------------------------------
                If ( .Step == .Step_Build )
                {
                    Using( .FinalProperties )

                    If ( .ProjectKind == .Kind_HeaderOnly )
                    {
                        .Piepline_CompileVSTargets_Extension =
                        [
                            .PipelineSolutionInfo =
                            [
                                .'SolutionInfo_$ProjectTarget$'  =
                                [
                                    .Intellisense =
                                    [
                                        .IncludeDirs = .IncludeDirs
                                        .Defines = .Defines
                                        .BuildOptions = .BuildOptions
                                    ]
                                ]
                            ]
                        ]
                        ^Piepline_CompileVSTargets + .Piepline_CompileVSTargets_Extension
                        ^Piepline_CompileVSTargetsNames + .ProjectTarget
                    }
                }

                Using( .PipelineStepTasks )
                Using( .Step_TargetsContainer )

                .PreBuildDependencies = .StepDependencies
                .PreviousTargets = .'Step_Targets_$Step_Previous$'
                .PreviousOutputs = .'Step_Outputs_$Step_Previous$'

                .CurrentTargets = { }
                .CurrentTargets_Unused = { }
                .CurrentOutputs = { }

                .TaskIdx = 0
                .TaskVSTargetSaved = false

                .AllowUnityBuilds = true

                ForEach( .Task in .'$Step$_Tasks' )
                {
                    .Type = 'Unknown'
                    .TargetsList = 'CurrentTargets'

                    // // 'Compile' and 'Execute' Task default values
                    // .TaskID = ''
                    .TaskCompiler = .ToolchainCompiler
                    .TaskCompilerFrontend = .ToolchainFrontend
                    .TaskUseTargets = true
                    .TaskInputAllowNoFiles = false
                    .TaskInputPattern = { '.cpp', '.cxx' }
                    .TaskCustomOptions = ''
                    .TaskConsumesPreviousOutputs = false

                    Using( .Task )

                    // // Set the taskID as the type
                    // If ( .TaskID == .EmptyString )
                    // {
                    //     ^TaskID = .Type
                    // }

                    If ( !.TaskUseTargets )
                    {
                        ^TargetsList + '_Unused'
                    }

                    If ( !.PipelineAllowUnityBuilds )
                    {
                        ^AllowUnityBuilds = false
                    }

                    If ( !.ProjectAllowUnityBuilds )
                    {
                        ^AllowUnityBuilds = false
                    }

                    // If we are using an unknown task type
                    If ( .Type not in .TaskType_ValidList )
                    {
                        Error( "Task has a unknown type: $Type$" )
                    }

                    // Hide all targets defined in this scope or lower that can be hidden
                    .Hidden = true

                    If( .Type == .TaskType_Compile )
                    {
                        Using( .FinalProperties )
                        Using( .'CompilerFrontend_$TaskCompilerFrontend$' )
                        Using( .FrontendProperties )

                        {
                            .Variables = {
                                'IncludeDirs'
                                'IncludeResDirs'
                                'Defines'
                                'BuildOptions'
                            }

                            ForEach( .ConanModule in .ConanModules )
                            {
                                Using( .ConanModule )

                                ForEach( .Var in .'ConanVariables_$ProjectKind$' )
                                {
                                    Using( .'FrontendFlag_$Var$' )
                                    ForEach( .Value in .'$Var$' )
                                    {
                                        ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                    }
                                }
                            }

                            ForEach( .Var in .Variables )
                            {
                                Using( .'FrontendFlag_$Var$' )

                                ForEach( .Value in .'$Var$' )
                                {
                                    ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                }
                            }
                        }

                        If ( .ProjectKind != .Kind_HeaderOnly )
                        {
                            .Compiler = .TaskCompiler
                            .CompilerOutputPath = .TargetIntermediateDirectory
                            .CompilerInputUnity = { }
                            .CompilerInputPath = .ProjectSourcePaths
                            .CompilerInputPattern = .TaskInputPattern
                            .CompilerInputAllowNoFiles = .TaskInputAllowNoFiles
                            .CompilerOptions + .TaskCustomOptions
                            .CompilerInputObjectLists = { }

                            If ( .TaskConsumesPreviousOutputs )
                            {
                                ^CompilerInputObjectLists + .PreviousTargets // Requires a different option probably
                            }

                            // Unity files
                            //--------------------------------------------------------------------------
                            If ( .AllowUnityBuilds )
                            {
                                Unity( '$ProjectTarget$-$TaskIdx$-unity' )
                                {
                                    .UnityInputPath = .ProjectSourcePaths
                                    .UnityInputPattern = .CompilerInputPattern
                                    .UnityOutputPath = .TargetIntermediateDirectory
                                    .UnityOutputPattern = 'unity_$ProjectName$_*.cxx'
                                }

                                // Reset compiler input paths
                                ^CompilerInputUnity = '$ProjectTarget$-$TaskIdx$-unity'
                                ^CompilerInputPath = { }
                            }

                            // Object list
                            //--------------------------------------------------------------------------
                            ObjectList( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'

                            If ( !.TaskVSTargetSaved )
                            {
                                ^TaskVSTargetSaved = true

                                .Piepline_CompileVSTargets_Extension =
                                [
                                    .'CompileTarget_$ProjectTarget$' = '$ProjectTarget$-$TaskIdx$-$Step$'
                                ]
                                ^Piepline_CompileVSTargets + .Piepline_CompileVSTargets_Extension
                                ^Piepline_CompileVSTargetsNames + .ProjectTarget
                            }
                        }
                    }

                    If( .Type == .TaskType_Link )
                    {
                        Using( .FinalProperties )
                        Using( .'CompilerFrontend_$TaskCompilerFrontend$' )
                        Using( .FrontendProperties )

                        {
                            .Variables = {
                                'LibDirs'
                                'Libs'
                                'LinkOptions'
                            }

                            ForEach( .ConanModule in .ConanModules )
                            {
                                Using( .ConanModule )

                                ForEach( .Var in .'ConanVariables_$ProjectKind$' )
                                {
                                    Using( .'FrontendFlag_$Var$' )
                                    ForEach( .Value in .'$Var$' )
                                    {
                                        ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                    }
                                }
                            }

                            ForEach( .Var in .Variables )
                            {
                                Using( .'FrontendFlag_$Var$' )

                                If( .ProjectKind == .Kind_StaticLib )
                                {
                                    .Const_LinkOptions = 'LinkOptions'
                                    If ( .Var == .Const_LinkOptions )
                                    {
                                        ^FlagVariable = 'LibrarianOptions'
                                    }
                                }

                                If ( .ProjectKind != .Kind_StaticLib )
                                {
                                    .Const_LinkOptions = 'LinkOptions'
                                    If ( .Var == .Const_LinkOptions )
                                    {
                                        ForEach( .Value in .LinkLinkerOptions )
                                        {
                                            ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                        }
                                    }
                                }

                                ForEach( .Value in .'$Var$' )
                                {
                                    ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                }
                            }
                        }

                        // Object List target
                        If ( .ProjectKind == .Kind_ObjectList )
                        {
                            Alias( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                                .Targets = .PreviousTargets
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'
                        }

                        // Static Library target
                        //--------------------------------------------------------------------------
                        If ( .ProjectKind == .Kind_StaticLib )
                        {
                            .Compiler = .ToolchainCompiler
                            .CompilerOutputPath = .TargetIntermediateDirectory

                            .Librarian = .ToolchainLibrarian
                            .LibrarianAdditionalInputs = .PreviousTargets
                            .LibrarianOutput = '$TargetOutputDirectory$/$TargetOutputName$'

                            Library( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'
                        }

                        // Shared Library target
                        //--------------------------------------------------------------------------
                        If ( .ProjectKind == .Kind_SharedLib )
                        {
                            .Libraries = .PreviousTargets
                            ForEach( .Library in .LibraryTargets )
                            {
                                ^Libraries + '$Library$-$TargetTriple$-$PipelineToolchain$-$Step$'
                            }

                            .Linker = .ToolchainLinker
                            .LinkerOutput = '$TargetOutputDirectory$/$TargetOutputName$'

                            DLL( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^CurrentOutputs + .LinkerOutput
                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'

                            .Name = .ProjectName
                            .LocalCompilerConfig = .EmptyString
                            .LocalCompilerModule = false

                            Using ( .ProjectLocalCompiler )
                            If ( .PipelineDefinesCompilers && .LocalCompilerModule && (.LocalCompilerConfig == .PipelineConfig) )
                            {
                                Alias( '$Name$-compiler-module' )
                                {
                                    .Targets = '$ProjectTarget$-$TaskIdx$-$Step$'
                                }

                                Using( .ProjectStepDependencies )

                                .Pipeline_LocalCompilerTarget =
                                [
                                    .'LocalCompilerTarget_$Name$' = { '$ProjectTarget$-$TaskIdx$-$Step$' } + .RuntimeExternal
                                ]
                                ^Pipeline_LocalCompilerTargets + .Pipeline_LocalCompilerTarget
                            }
                        }

                        // Executable targets
                        //--------------------------------------------------------------------------
                        If ( .ProjectKind in .Kind_Applications )
                        {
                            .Libraries = .PreviousTargets
                            ForEach( .Library in .LibraryTargets )
                            {
                                ^Libraries + '$Library$-$TargetTriple$-$PipelineToolchain$-$Step$'
                            }

                            .Linker = .ToolchainLinker
                            .LinkerOutput = '$TargetOutputDirectory$/$TargetOutputName$'

                            Executable( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^CurrentOutputs + .LinkerOutput
                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'

                            .Type = 'compiler'
                            .Name = .ProjectName
                            .LocalCompilerConfig = .EmptyString
                            .LocalCompilerModule = false
                            .LocalCompilerModuleList = { }

                            Using ( .ProjectLocalCompiler )
                            If ( .PipelineDefinesCompilers && (.LocalCompilerConfig == .PipelineConfig) )
                            {
                                If ( !.LocalCompilerModule )
                                {

                                    Using( .Pipeline_LocalCompilerTargets )

                                    .Runtime = { }
                                    .RuntimeExternal = { }
                                    Using( .ProjectStepDependencies )
                                    ForEach( .Dependency in .Runtime )
                                    {
                                        If ( .Dependency in .PipelineEnabledProjects )
                                        {
                                            ^LocalCompilerModuleList + .Dependency
                                        }
                                    }

                                    // Resolve extra files
                                    .BinaryFiles = { }
                                    ForEach( .ModuleTarget in .LocalCompilerModuleList )
                                    {
                                        ^BinaryFiles + .'LocalCompilerTarget_$ModuleTarget$'
                                    }

                                    // External runtime dependencies (shared objects required by platforms)
                                    ForEach( .Dependency in .RuntimeExternal )
                                    {
                                        If ( .Dependency not in .BinaryFiles )
                                        {
                                            ^BinaryFiles + .Dependency
                                        }
                                    }

                                    Copy( '$ProjectTarget$-$TaskIdx$-$Step$-deploy-compiler-modules' )
                                    {
                                        .Source = .BinaryFiles
                                        .Dest = "$TargetDeployDirectory$/"
                                    }

                                    .DeployOutput = '$TargetDeployDirectory$/$TargetOutputName$'
                                    Copy( '$ProjectTarget$-$TaskIdx$-$Step$-deploy-compiler' )
                                    {
                                        .Source = .LinkerOutput
                                        .Dest = .DeployOutput
                                        .PreBuildDependencies = { '$ProjectTarget$-$TaskIdx$-$Step$-deploy-compiler-modules' }
                                    }

                                    If ( .Type == 'compiler' )
                                    {
                                        Compiler( '$Name$-compiler' )
                                        {
                                            .Executable = .DeployOutput
                                            .ExtraFiles = .BinaryFiles
                                            .CompilerFamily = "Custom"
                                        }

                                        ^Final_GlobalTags + '$Name$-compiler'
                                    }
                                    If ( .Type != 'compiler' )
                                    {
                                        Alias( '$Name$-$Type$' )
                                        {
                                            .Targets = '$ProjectTarget$-$TaskIdx$-$Step$'
                                        }

                                        ^Final_GlobalTags + '$Name$-$Type$'
                                    }
                                }
                                If ( .LocalCompilerModule )
                                {
                                    Alias( '$Name$-compiler-module' )
                                    {
                                        .Targets = '$ProjectTarget$-$TaskIdx$-$Step$'
                                    }

                                    .Pipeline_LocalCompilerTarget =
                                    [
                                        .'$Name$' = .LinkerOutput
                                    ]
                                    ^Pipeline_LocalCompilerTargets + .Pipeline_LocalCompilerTarget

                                    ^Final_GlobalTags + '$Name$-compiler-module'
                                }
                            }
                        }
                    }

                    If ( .Type == .TaskType_Test )
                    {
                        If ( .ProjectKind in .Kind_Applications )
                        {
                            .Enabled = false

                            Using( .ProjectStepUnitTest )
                            If ( .Enabled )
                            {
                                ForEach( .PreviousTarget in .PreviousTargets )
                                {
                                    .TestExecutable = '$PreviousTarget$'
                                    .TestOutput = '$TargetTestOutputDirectory$/$ProjectName$_$Step$_test_results.txt'
                                    .TestWorkingDir = '$WorkspaceBuildDir$'

                                    Test( '$PreviousTarget$-test' )
                                    {
                                    }

                                    ^'$TargetsList$' + '$PreviousTarget$-test'
                                }
                            }
                        }
                    }

                    If ( .Step == .Step_Deploy )
                    {
                        If ( .ProjectDeploy )
                        {
                            If ( .Type == .TaskType_Deploy )
                            {
                                If ( .ProjectKind in .Kind_Executable )
                                {
                                    .PreBuildDependencies = .PreviousTargets + .CurrentTargets + .CurrentTargets_Unused
                                    .BinaryFiles = .Step_Outputs_Link

                                    .Runtime = { }
                                    .RuntimeExternal = { }
                                    Using( .ProjectStepDependencies )

                                    // Prepare runtime dependencies to be deployed
                                    ForEach( .Dependency in .Runtime )
                                    {
                                        If ( .Dependency in .PipelineEnabledProjects )
                                        {
                                            ^BinaryFiles + '$Dependency$-$TargetTriple$-$PipelineToolchain$-Link'
                                        }
                                    }
                                    // External runtime dependencies (shared objects required by platforms)
                                    ForEach( .Dependency in .RuntimeExternal )
                                    {
                                        If ( .Dependency not in .BinaryFiles )
                                        {
                                            ^BinaryFiles + .Dependency
                                        }
                                    }

                                    // Copy operation
                                    Copy( '$ProjectTarget$-$Step$-binary' )
                                    {
                                        .Source = .BinaryFiles
                                        .Dest = "$TargetDeployDirectory$/"
                                    }

                                    ^CurrentTargets_Unused + { '$ProjectTarget$-$Step$-binary' }
                                }
                            }
                        }
                    }

                    If ( .Type == .TaskType_Exec )
                    {
                        .PreBuildDependencies = .PreviousTargets + .CurrentTargets + .CurrentTargets_Unused

                        .ExecOutput = '$TargetTaskOutputDirectory$/$TaskID$/$TaskExecOutput$'

                        If ( .TaskConsumesPreviousOutputs )
                        {
                            ^ExecInput = .PreviousOutputs
                        }

                        Exec( '$ProjectTarget$-$Step$-$TaskID$' )
                        {
                        }

                        ^CurrentOutputs + .ExecOutput
                        ^CurrentTargets_Unused = '$ProjectTarget$-$Step$-$TaskID$'
                    }

                    ^TaskIdx + 1
                } // ForEach( .Task in .'$Step$_Tasks' )

                {
                    .HasTargets = false
                    .HasDependencies = false

                    .AllCurrentTargets = .CurrentTargets + .CurrentTargets_Unused

                    ForEach ( ._ in .AllCurrentTargets )
                    {
                        ^HasTargets = true
                    }
                    ForEach ( ._ in .StepDependencies )
                    {
                        ^HasDependencies = true
                    }

                    If ( .HasTargets )
                    {
                        Alias( '$ProjectTarget$-$Step$' )
                        {
                            .Targets = .AllCurrentTargets
                        }

                        ^ProjectSubTargets + '$ProjectTarget$-$Step$'
                    }

                    If ( !.HasTargets )
                    {
                        If ( .HasDependencies )
                        {
                            Alias( '$ProjectTarget$-$Step$' )
                            {
                                .Targets = .StepDependencies
                            }

                            ^ProjectSubTargets + '$ProjectTarget$-$Step$'
                        }
                    }
                }

                // Save the created targets
                .Step_TargetsContainer_Extension =
                [
                    .'Step_Targets_$Step$' = .CurrentTargets
                    .'Step_Outputs_$Step$' = .CurrentOutputs
                ]
                ^Step_TargetsContainer + .Step_TargetsContainer_Extension
                ^Step_Previous = .Step

            } // ForEach( .Step in .PipelineSteps )

            If ( .ProjectKind != .Kind_HeaderOnly )
            {
                Alias( '$ProjectTarget$' )
                {
                    .Targets = .ProjectSubTargets
                }

                ^PipelineTargets + '$ProjectTarget$'
            }

        } // If ( .ProjectRequirementsSatisfied )
    } // ForEach( .Project in .ProjectsResolved )

    {
        .HasTargets = false
        ForEach ( ._ in .PipelineTargets )
        {
            ^HasTargets = true
        }

        If ( .HasTargets )
        {
            .Target = 'all-$PipelineName$-$PipelineConfig$'
            Alias( .Target )
            {
                .Targets = .PipelineTargets
            }
            ^Final_AliasList + .Target

            .Target = 'all-$PipelineName$-$PipelineConfig$-clean'
            Alias( .Target )
            {
                .Targets = .PipelineCleanTargets
            }
            ^Final_CleanAliasList + .Target
        }
    }

} // ForEach( .Pipeline in .AvailablePipelines )

{
    .HasTargets = false
    ForEach ( ._ in .Final_AliasList )
    {
        ^HasTargets = true
    }

    If ( .HasTargets )
    {
        Alias( 'all' )
        {
            .Targets = .Final_AliasList
        }

        Alias( 'all-clean' )
        {
            .Targets = .Final_CleanAliasList
        }
    }
}

Print( '[IBT] Build targets created.' )

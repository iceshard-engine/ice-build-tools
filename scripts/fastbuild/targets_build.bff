
.KindOutDir_StaticLib = 'lib'
.KindOutDir_SharedLib = 'bin'
.KindOutDir_ConsoleApp = 'bin'
.KindOutDir_WindowedApp = 'bin'
.KindOutDir_HeaderOnly = 'inc'
.KindOutDir_ObjectList = ''

.ConanVariables_StaticLib = { 'IncludeDirs', 'Defines' }
.ConanVariables_SharedLib = { 'IncludeDirs', 'Defines', 'LibDirs', 'Libs' }
.ConanVariables_ConsoleApp = { 'IncludeDirs', 'Defines', 'LibDirs', 'Libs' }
.ConanVariables_WindowedApp = { 'IncludeDirs', 'Defines', 'LibDirs', 'Libs' }
.ConanVariables_HeaderOnly = { 'IncludeDirs', 'Defines' }
.ConanVariables_ObjectList = { 'IncludeDirs', 'Defines' }

.TaskType_Compile = 'Compile'
.TaskType_Link = 'Link'
.TaskType_Test = 'Test'
.TaskType_Exec = 'Exec'
.TaskType_ValidList = {
    .TaskType_Compile,
    .TaskType_Link
    .TaskType_Test
    .TaskType_Exec
}

.Piepline_CompileVSTargets =
[
]

//
// Prepare global build rules
//
.Final_GlobalRules = { }
ForEach( .GlobalRule in .GlobalRules )
{
    Using( .EmptyProperties )
    Using( .GlobalRule )

    .Final_GlobalRule =
    [
        .Name = .Name
        .RuleRequires = .Requires
        .RuleDependsOn = []
        .RuleProperties_Public = [ ]
        .RuleProperties_Private =
        [
            .Uses = .Uses
            .Modules = ^Modules
            .IncludeDirs = ^IncludeDirs
            .Defines = ^Defines
            .BuildOptions = ^BuildOptions
            .Libs = ^Libs
            .LibDirs = ^LibDirs
            .LinkOptions = ^LinkOptions
        ]
    ]
    ^Final_GlobalRules + .Final_GlobalRule
}


//
// For each available pipeline create all targets
//
ForEach( .Pipeline in .AvailablePipelines )
{
    Using( .Pipeline )

    .PipelineTargets = { }
    .PipelineEnabledProjects = { }
    .PipelineProperties_Public = []

    ForEach( .Project in .ProjectsResolved )
    {
        .ProjectAllowUnityBuilds = true

        Using( .Project )

        .AvailableTags = .SDKNames
            + .PipelineTags

        // Check if we the project has all requirements covered
        .ProjectRequirementsSatisfied = true
        {
            .AvailableTags + .PipelineEnabledProjects

            ForEach( .Requirement in .ProjectRequires )
            {
                If ( .Requirement not in .AvailableTags )
                {
                    Print( "INFO: $ProjectName$ is missing requirement `$Requirement$` for ($PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$)" )
                    ^ProjectRequirementsSatisfied = false
                }
            }
        }

        // Build targets for the project
        If ( .ProjectRequirementsSatisfied )
        {
            ^PipelineEnabledProjects + .ProjectName

            .AvailableTags
                + .ProjectTags
                + .ProjectKind

            // Final list of rules for the current step
            .StepRules = { }
            ForEach( .PipelineRule in .PipelineRules )
            {
                Using( .EmptyProperties )
                Using( .PipelineRule )

                .Final_PipelineRule =
                [
                    .Name = .Name
                    .RuleRequires = .Requires
                    .RuleDependsOn = []
                    .RuleProperties_Public = [ ]
                    .RuleProperties_Private =
                    [
                        .Uses = .Uses
                        .Modules = ^Modules
                        .IncludeDirs = ^IncludeDirs
                        .Defines = ^Defines
                        .BuildOptions = ^BuildOptions
                        .Libs = ^Libs
                        .LibDirs = ^LibDirs
                        .LinkOptions = ^LinkOptions
                    ]
                ]
                ^StepRules + .Final_PipelineRule
            }

            .StepRules
                + .ProjectRules
                + .Final_GlobalRules

            // .ProjectTarget = '$ProjectName$-$PipelineName$-$PipelineConfig$'
            .ProjectTarget = '$ProjectName$-$PipelineName$-$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$'
            .ProjectStruct = '$ProjectName$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
            .ProjectSubTargets = { }

            Using( .EmptyProperties )

            // Prepare a struct where we can hold all targets defined in a step
            .Step_Previous = 'INIT'
            .Step_TargetsContainer =
            [
                .Step_Targets_INIT = {}
            ]

            // Some helper variables so we dont duplicate target creation
            .Step_CopyDirsTargets = { }


            // Go through each step
            ForEach( .Step in .PipelineSteps )
            {
                .AvailableTags + "Step-$Step$"

                .ProjectStepStruct = 'PublicProperties_$Step$_$ProjectStruct$'
                .ProjectStepProperties_Public = []
                .ProjectStepProperties_Combined = []
                .ProjectStepDependencies = []
                .ProjectStepDeploys = { }
                .ProjectStepUnitTest = [ ]

                ForEach( .Rule in .StepRules )
                {
                    .RuleRequirementsSatisfied = true

                    // Check if we ment the rule requirements
                    .Name = "<null>"
                    .RuleRequires = { }

                    Using( .EmptyProperties )
                    Using( .Rule )

                    ForEach( .Dependency in .Uses )
                    {
                        ^RuleRequires + '$Dependency$-$PipelineName$-$ConfigPlatform$-$ConfigName$'
                    }

                    ForEach( .Requirement in .RuleRequires )
                    {
                        If ( .Requirement not in .AvailableTags )
                        {
                            ^RuleRequirementsSatisfied = false
                        }
                    }

                    // Print( "$ProjectName$ $Step$ ($Name$) == $RuleRequirementsSatisfied$" )

                    If ( .RuleRequirementsSatisfied )
                    {
                        .RuleKind = .Kind_None
                        .RuleDeploy =
                        [
                            .Executable = .EmptyString
                        ]
                        .RuleUnitTests =
                        [
                            .Enabled = false
                        ]

                        // Update project kind if needed
                        If ( .RuleKind != .Kind_None )
                        {
                            ^ProjectKind = .RuleKind
                        }

                        // Gether dependency properties
                        .GatheredDependencies = { }
                        .GatheredProperties = {
                            'Modules'
                            'Defines'
                            'IncludeDirs'
                            'BuildOptions'
                            'Libs'
                            'LibDirs'
                            'LinkOptions'
                            'DependsOn'
                        }

                        Using( .EmptyProperties )

                        .RuleStepProject_FinalProperties_Public =
                        [
                            Using( .RuleProperties_Public )

                            // Create empty dependency property structs
                            .PipelineProperties_Public_Empty = []
                            {
                                ForEach( .Dependency in .Uses )
                                {
                                    .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                    .PipelineProperties_Public_Empty_Extension =
                                    [
                                        .'$DependencyStruct$' =
                                        [
                                            Using( .EmptyProperties )
                                            .HasLinkTarget = false
                                            ; .CopyModules = false
                                        ]
                                    ]
                                    ^PipelineProperties_Public_Empty + .PipelineProperties_Public_Empty_Extension
                                }
                            }

                            {
                                Using( .PipelineProperties_Public_Empty )
                                Using( .PipelineProperties_Public )

                                // Gather public uses
                                {
                                    .UsesUnique = .Uses
                                    ForEach( .Dependency in .Uses )
                                    {
                                        .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                        Using( .'$DependencyStruct$' )

                                        ForEach( .Value in .Uses )
                                        {
                                            If ( .Value not in .UsesUnique )
                                            {
                                                ^UsesUnique + .Value
                                            }
                                        }
                                    }
                                    ^Uses = .UsesUnique
                                }
                            }
                        ]

                        // Enable `interface` dependency visibility for less restrictive build setup
                        .RuleStepProject_FinalProperties_Interface =
                        [
                        ]

                        .RuleStepProject_FinalProperties_Private =
                        [
                            Using( .RuleProperties_Private )

                            // Create empty dependency property structs
                            .PipelineProperties_Private_Empty = []
                            {
                                ForEach( .Dependency in .Uses )
                                {
                                    .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                    .PipelineProperties_Private_Empty_Extension =
                                    [
                                        .'$DependencyStruct$' =
                                        [
                                            Using( .EmptyProperties )
                                            .HasLinkTarget = false
                                            ; .CopyModules = false
                                        ]
                                    ]
                                    ^PipelineProperties_Private_Empty + .PipelineProperties_Private_Empty_Extension
                                }
                            }

                            {
                                Using( .PipelineProperties_Private_Empty )
                                Using( .PipelineProperties_Public )

                                // Gather public uses
                                {
                                    .UsesUnique = .Uses
                                    ForEach( .Dependency in .Uses )
                                    {
                                        .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                        Using( .'$DependencyStruct$' )

                                        ForEach( .Value in .Uses )
                                        {
                                            If ( .Value not in .UsesUnique )
                                            {
                                                ^UsesUnique + .Value
                                            }
                                        }
                                    }
                                    ^Uses = .UsesUnique
                                }
                            }
                        ]

                        .RuleFinalCombinedProperties = [ ]
                            + .RuleStepProject_FinalProperties_Private
                            + .RuleStepProject_FinalProperties_Interface
                            + .RuleStepProject_FinalProperties_Public

                        .RuleStepProject_FinalProperties_Combined =
                        [
                            Using( .RuleFinalCombinedProperties )

                            // Create empty dependency property structs
                            .PipelineProperties_Private_Empty = []
                            {
                                ForEach( .Dependency in .Uses )
                                {
                                    .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'
                                    .PipelineProperties_Private_Empty_Extension =
                                    [
                                        .'$DependencyStruct$' =
                                        [
                                            Using( .EmptyProperties )
                                            .HasLinkTarget = false
                                            ; .CopyModules = false
                                        ]
                                    ]
                                    ^PipelineProperties_Private_Empty + .PipelineProperties_Private_Empty_Extension
                                }
                            }

                            .LibraryTargets = { }

                            {
                                Using( .PipelineProperties_Private_Empty )
                                Using( .PipelineProperties_Public )

                                ForEach( .Dependency in .Uses )
                                {
                                    If ( .Dependency not in .GatheredDependencies )
                                    {
                                        ^GatheredDependencies + .Dependency
                                        .DependencyStruct = 'PublicProperties_$Step$_$Dependency$_$PipelineName$_$PipelinePlatform$_$PipelineConfig$_$PipelineToolchainStruct$'

                                        // Print( "$ProjectName$: Gathering $Dependency$..." )

                                        ForEach( .Property in .GatheredProperties )
                                        {
                                            Using( .'$DependencyStruct$' )
                                            ^'$Property$' + .'$Property$'
                                        }

                                        {
                                            Using( .'$DependencyStruct$' )
                                            If ( .HasLinkTarget )
                                            {
                                                ^LibraryTargets + .Dependency
                                            }
                                        }
                                    }
                                }
                            }

                            .Uses = .GatheredDependencies

                            ^ProjectStepDependencies + .DependsOn
                        ]

                        ^ProjectStepProperties_Public + .RuleStepProject_FinalProperties_Public
                        ^ProjectStepProperties_Combined + .RuleStepProject_FinalProperties_Combined
                        ^ProjectRequires + .RuleRequires

                        {
                            Using( .Rule )
                            Using( .RuleDeploy )
                            If ( .Executable != .EmptyString )
                            {
                                .DeployEntry =
                                [
                                    .DeployName = .RuleName
                                    Using( .RuleDeploy )
                                ]
                                ^ProjectStepDeploys + .DeployEntry
                            }
                        }

                        {
                            Using( .Rule )
                            Using( .RuleUnitTests )
                            If ( .Enabled )
                            {
                                ^ProjectStepUnitTest = .RuleUnitTests
                            }
                        }
                    }

                } // ForEach( .Rule in .ProjectPipelineConfigRules )

                // Update the public struct of the project
                {
                    .PipelineProperties_PublicExtension =
                    [
                        .'$ProjectStepStruct$' =
                        [
                            Using( .ProjectStepProperties_Public )

                            .HasLinkTarget = true
                            If ( .ProjectKind == .Kind_HeaderOnly )
                            {
                                ^HasLinkTarget = false
                            }
                        ]
                    ]
                    ^PipelineProperties_Public + .PipelineProperties_PublicExtension
                }

                Using( .PipelineOutputExtensions )
                Using( .PipelineToolchainInfo )

                // Print( "Target: $ProjectTarget$" )

                .OutDirName = .'KindOutDir_$ProjectKind$'
                .TargetExtension = .'OutputExtension_$ProjectKind$'

                .TargetIntermediateDirectory = '$WorkspaceBuildDir$/obj/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$/$ProjectName$'
                .TargetImpLibDirectory = '$WorkspaceBuildDir$/lib/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$/$ProjectName$'
                .TargetOutputDirectory = '$WorkspaceBuildDir$/$OutDirName$/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$/$ProjectName$'
                .TargetTestOutputDirectory = '$WorkspaceBuildDir$/tests/$PipelineName$/$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$'
                .TargetOutputName = "$ProjectName$$TargetExtension$"
                .TargetList = { }

                // Print( "IntDir: $TargetIntermediateDirectory$" )
                // Print( "LibDir: $TargetImpLibDirectory$" )
                // Print( "Output: $TargetOutputDirectory$/$TargetOutputName$" )
                // Print( .RuleProperties )

                // Dependency list
                //--------------------------------------------------------------------------
                .StepDependencies = { }

                {
                    .'$Step$' = {}

                    Using( .ProjectStepDependencies )

                    ForEach( .Dependency in .'$Step$' )
                    {
                        If ( .Dependency in .PipelineEnabledProjects )
                        {
                            .DependencyTargetName = '$Dependency$-$PipelineName$-$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$'
                            ^StepDependencies + .DependencyTargetName
                        }
                    }
                }


                .FinalProperties = .ProjectStepProperties_Combined

                // Project specific SDK
                ForEach( .SDKName in .SDKNames, .SDK in .SDKList )
                {
                    If ( .SDKName not in .PipelineTags )
                    {
                        If ( .SDKName in .ProjectRequires )
                        {
                            ^FinalProperties + .SDK
                        }
                    }
                }

                .FinalProperties
                    + .PipelineProperties_SDKs
                    + .PipelineProperties_Toolchain

                // Conan Modules
                //--------------------------------------------------------------------------
                .ProcessedConanModules = { }

                {
                    Using( .FinalProperties )
                    Using( .'ConanModules_$PipelineConfigConan$' )

                    ForEach( .ConanModule in .Modules )
                    {
                        If ( .ConanModule not in .ProcessedConanModules )
                        {
                            ^ProcessedConanModules + .ConanModule

                            Using( .'ConanModule_$ConanModule$' )
                            If ( .CopyModules )
                            {

                                .CopyDirs = false
                                .CopyDirsList = { }
                                ForEach( .BinDir in .BinDirs )
                                {
                                    ^CopyDirs = true
                                    ^CopyDirsList + "$BinDir$/"
                                }

                                If ( .CopyDirs )
                                {
                                    .CopyDirTargetName = '$ProjectTarget$-$ConanModule$-copydir'

                                    If ( .CopyDirTargetName not in .Step_CopyDirsTargets )
                                    {
                                        // Only do this once
                                        ^Step_CopyDirsTargets + .CopyDirTargetName

                                        CopyDir( '$CopyDirTargetName$' )
                                        {
                                            .SourcePaths = .CopyDirsList
                                            .SourcePathsPattern = '*.dll'
                                            .Dest = .TargetOutputDirectory
                                        }
                                        ^StepDependencies + '$ProjectTarget$-$ConanModule$-copydir'
                                    }
                                }
                            }
                        }
                    }
                }

                // Apply link step all flags
                //--------------------------------------------------------------------------
                {
                    Using( .FinalProperties )

                    If ( .ProjectKind == .Kind_HeaderOnly )
                    {
                        .Piepline_CompileVSTargets_Extension =
                        [
                            .'SolutionInfo_$ProjectTarget$' =
                            [
                                .Intellisense =
                                [
                                    .IncludeDirs = .IncludeDirs
                                    .Defines = .Defines
                                    .BuildOptions = .BuildOptions
                                ]
                            ]
                        ]
                        ^Piepline_CompileVSTargets + .Piepline_CompileVSTargets_Extension
                    }
                }

                Using( .PipelineStepTasks )
                Using( .Step_TargetsContainer )

                .PreBuildDependencies = .StepDependencies
                .PreviousTargets = .'Step_Targets_$Step_Previous$'

                .CurrentTargets = { }
                .CurrentTargets_Unused = { }

                .TaskIdx = 0
                .TaskVSTargetSaved = false

                .AllowUnityBuilds = true

                ForEach( .Task in .'$Step$_Tasks' )
                {
                    .Type = 'Unknown'
                    .TargetsList = 'CurrentTargets'

                    .TaskCompiler = .ToolchainCompiler
                    .TaskCompilerFamily = .ToolchainCompilerFamily
                    .TaskUseTargets = true
                    .TaskInputAllowNoFiles = false
                    .TaskInputPattern = { '.cpp', '.cxx' }
                    .TaskCustomOptions = ''

                    Using( .Task )

                    If ( !.TaskUseTargets )
                    {
                        ^TargetsList + '_Unused'
                    }

                    If ( !.PipelineAllowUnityBuilds )
                    {
                        ^AllowUnityBuilds = false
                    }

                    If ( !.ProjectAllowUnityBuilds )
                    {
                        ^AllowUnityBuilds = false
                    }

                    // If we are using an unknown task type
                    If ( .Type not in .TaskType_ValidList )
                    {
                        Error( "Task has a unknown type: $Type$" )
                    }

                    If( .Type == .TaskType_Compile )
                    {
                        Using( .FinalProperties )
                        Using( .'CompilerFrontend_$TaskCompilerFamily$' )
                        Using( .FrontendProperties )

                        {
                            .Variables = {
                                'IncludeDirs'
                                'IncludeResDirs'
                                'Defines'
                                'BuildOptions'
                            }

                            Using( .'ConanModules_$PipelineConfigConan$' )
                            ForEach( .ConanModule in .ProcessedConanModules )
                            {
                                Using( .'ConanModule_$ConanModule$' )

                                ForEach( .Var in .'ConanVariables_$ProjectKind$' )
                                {
                                    Using( .'FrontendFlag_$Var$' )
                                    ForEach( .Value in .'$Var$' )
                                    {
                                        ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                    }
                                }
                            }

                            ForEach( .Var in .Variables )
                            {
                                Using( .'FrontendFlag_$Var$' )

                                ForEach( .Value in .'$Var$' )
                                {
                                    ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                }
                            }
                        }

                        If ( .ProjectKind != .Kind_HeaderOnly )
                        {
                            .Compiler = .TaskCompiler
                            .CompilerOutputPath = .TargetIntermediateDirectory
                            .CompilerInputUnity = { }
                            .CompilerInputPath = .ProjectSourcePaths
                            .CompilerInputPattern = .TaskInputPattern
                            .CompilerInputAllowNoFiles = .TaskInputAllowNoFiles
                            .CompilerOptions + .TaskCustomOptions

                            // Unity files
                            //--------------------------------------------------------------------------
                            If ( .AllowUnityBuilds )
                            {
                                Unity( '$ProjectTarget$-$TaskIdx$-unity' )
                                {
                                    .UnityInputPath = .ProjectSourcePaths
                                    .UnityInputPattern = .CompilerInputPattern
                                    .UnityOutputPath = .TargetIntermediateDirectory
                                    .UnityOutputPattern = 'unity_$ProjectName$_*.cxx'
                                }

                                // Reset compiler input paths
                                ^CompilerInputUnity = '$ProjectTarget$-$TaskIdx$-unity'
                                ^CompilerInputPath = { }
                            }

                            // Object list
                            //--------------------------------------------------------------------------
                            ObjectList( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'

                            If ( !.TaskVSTargetSaved )
                            {
                                ^TaskVSTargetSaved = true

                                .Piepline_CompileVSTargets_Extension =
                                [
                                    .'CompileTarget_$ProjectTarget$' = '$ProjectTarget$-$TaskIdx$-$Step$'
                                ]
                                ^Piepline_CompileVSTargets + .Piepline_CompileVSTargets_Extension
                            }
                        }
                    }

                    If( .Type == .TaskType_Link )
                    {
                        Using( .FinalProperties )
                        Using( .'CompilerFrontend_$TaskCompilerFamily$' )
                        Using( .FrontendProperties )

                        {
                            .Variables = {
                                'LibDirs'
                                'Libs'
                                'LinkOptions'
                            }

                            Using( .'ConanModules_$PipelineConfigConan$' )
                            ForEach( .ConanModule in .ProcessedConanModules )
                            {
                                Using( .'ConanModule_$ConanModule$' )

                                ForEach( .Var in .'ConanVariables_$ProjectKind$' )
                                {
                                    Using( .'FrontendFlag_$Var$' )
                                    ForEach( .Value in .'$Var$' )
                                    {
                                        ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                    }
                                }
                            }

                            ForEach( .Var in .Variables )
                            {
                                Using( .'FrontendFlag_$Var$' )

                                If( .ProjectKind == .Kind_StaticLib )
                                {
                                    .Const_LinkOptions = 'LinkOptions'
                                    If ( .Var == .Const_LinkOptions )
                                    {
                                        ^FlagVariable = 'LibrarianOptions'
                                    }
                                }

                                ForEach( .Value in .'$Var$' )
                                {
                                    ^'$FlagVariable$' + ' $FlagPrefix$$Value$$FlagSuffix$'
                                }
                            }
                        }

                        // Object List target
                        If ( .ProjectKind == .Kind_ObjectList )
                        {
                            Alias( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                                .Targets = .PreviousTargets
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'
                        }

                        // Static Library target
                        //--------------------------------------------------------------------------
                        If ( .ProjectKind == .Kind_StaticLib )
                        {
                            .Compiler = .ToolchainCompiler
                            .CompilerOutputPath = .TargetIntermediateDirectory

                            .Librarian = .ToolchainLibrarian
                            .LibrarianAdditionalInputs = .PreviousTargets
                            .LibrarianOutput = '$TargetOutputDirectory$/$TargetOutputName$'

                            Library( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'
                        }

                        // Shared Library target
                        //--------------------------------------------------------------------------
                        If ( .ProjectKind == .Kind_SharedLib )
                        {
                            .Libraries = .PreviousTargets
                            ForEach( .Library in .LibraryTargets )
                            {
                                ^Libraries + '$Library$-$PipelineName$-$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$-$Step$'
                            }

                            .Linker = .ToolchainLinker
                            .LinkerOutput = '$TargetOutputDirectory$/$TargetOutputName$'

                            DLL( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'
                        }

                        // Executable targets
                        //--------------------------------------------------------------------------
                        If ( .ProjectKind in .Kind_Applications )
                        {
                            .Libraries = .PreviousTargets
                            ForEach( .Library in .LibraryTargets )
                            {
                                ^Libraries + '$Library$-$PipelineName$-$PipelinePlatform$-$PipelineConfig$-$PipelineToolchain$-$Step$'
                            }

                            .Linker = .ToolchainLinker
                            .LinkerOutput = '$TargetOutputDirectory$/$TargetOutputName$'

                            Executable( '$ProjectTarget$-$TaskIdx$-$Step$' )
                            {
                            }

                            ^'$TargetsList$' + '$ProjectTarget$-$TaskIdx$-$Step$'
                        }
                    }

                    If ( .Type == .TaskType_Test )
                    {
                        If ( .ProjectKind in .Kind_Applications )
                        {
                            .Enabled = false

                            Using( .ProjectStepUnitTest )
                            If ( .Enabled )
                            {
                                ForEach( .PreviousTarget in .PreviousTargets )
                                {
                                    .TestExecutable = '$PreviousTarget$'
                                    .TestOutput = '$TargetTestOutputDirectory$/$ProjectName$_$Step$_test_results.txt'
                                    .TestWorkingDir = '$WorkspaceBuildDir$'

                                    Test( '$PreviousTarget$-test' )
                                    {
                                    }

                                    ^'$TargetsList$' + '$PreviousTarget$-test'
                                }
                            }
                        }
                    }

                    If ( .Type == .TaskType_Exec )
                    {
                        If ( .ProjectKind != .Kind_HeaderOnly )
                        {
                            // TODO: Make this more generic, as this is explicitly a 'Deploy' step but should be just used for executing various tools
                            ForEach( .DeployEntry in .ProjectStepDeploys )
                            {
                                .Arguments = ''
                                .Inputs = { }
                                .Output = ''

                                Using( .DeployEntry )

                                If ( .Executable != .EmptyString )
                                {
                                    .PreBuildDependencies = .CurrentTargets + .CurrentTargets_Unused

                                    Exec( '$ProjectTarget$-$Step$-deploy-$DeployName$' )
                                    {
                                        .ExecExecutable = .Executable
                                        .ExecInput = .Inputs
                                        .ExecArguments = .Arguments
                                        .ExecOutput = .Output
                                        .ExecUseStdOutAsOutput = false
                                        .ExecAlwaysShowOutput = true
                                        .ExecAlways = true

                                        If ( .ExecOutput == .EmptyString )
                                        {
                                            ^ExecUseStdOutAsOutput = true
                                            ^ExecOutput = '$TargetOutputDirectory$/$ProjectName$_deploy_$Step$_$DeployName$_log.txt'
                                        }
                                    }

                                    ^'$TargetsList$' = '$ProjectTarget$-$Step$-deploy-$DeployName$'
                                }
                            }
                        }
                    }

                    ^TaskIdx + 1
                } // ForEach( .Task in .'$Step$_Tasks' )

                {
                    .HasTargets = false
                    .HasDependencies = false

                    .AllCurrentTargets = .CurrentTargets + .CurrentTargets_Unused

                    ForEach ( ._ in .AllCurrentTargets )
                    {
                        ^HasTargets = true
                    }
                    ForEach ( ._ in .StepDependencies )
                    {
                        ^HasDependencies = true
                    }

                    If ( .HasTargets )
                    {
                        Alias( '$ProjectTarget$-$Step$' )
                        {
                            .Targets = .AllCurrentTargets
                        }

                        ^ProjectSubTargets + '$ProjectTarget$-$Step$'
                    }

                    If ( !.HasTargets )
                    {
                        If ( .HasDependencies )
                        {
                            Alias( '$ProjectTarget$-$Step$' )
                            {
                                .Targets = .StepDependencies
                            }

                            ^ProjectSubTargets + '$ProjectTarget$-$Step$'
                        }
                    }
                }

                // Save the created targets
                .Step_TargetsContainer_Extension =
                [
                    .'Step_Targets_$Step$' = .CurrentTargets
                ]
                ^Step_TargetsContainer + .Step_TargetsContainer_Extension
                ^Step_Previous = .Step

            } // ForEach( .Step in .PipelineSteps )

            Alias( '$ProjectTarget$' )
            {
                .Targets = .ProjectSubTargets
            }

            ^PipelineTargets + '$ProjectTarget$'

        } // If ( .ProjectRequirementsSatisfied )
    } // ForEach( .Project in .ProjectsResolved )

    {
        .HasTargets = false
        ForEach ( ._ in .PipelineTargets )
        {
            ^HasTargets = true
        }

        If ( .HasTargets )
        {
            Alias( 'all-$PipelineName$-$PipelineConfig$' )
            {
                .Targets = .PipelineTargets
            }
        }
    }

} // ForEach( .Pipeline in .AvailablePipelines )
